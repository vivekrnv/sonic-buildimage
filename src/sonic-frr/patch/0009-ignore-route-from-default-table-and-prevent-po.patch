From 12627632ce98ebb0e64495458d84b296df84af28 Mon Sep 17 00:00:00 2001
From: Vivek Reddy <vkarri@nvidia.com>
Date: Fri, 19 May 2023 23:12:45 +0000
Subject: [PATCH] zebra: Ignore route from default table and Prevent possible
 crashed from use after free

a) Sonic has a host configuration process that places default routes into
the RT_TABLE_DEFAULT to allow for working without vrf's.  Additionally
the sonic fpmsyncd has no idea of actual table ids are and the actual
vrf id's are passed down to it instead.  As such the routes in table
RT_TABLE_DEFAULT would be passed down and cause issues in fpmsyncd
let's cut to the chase and stop this from happening.

Long term this is a real problem in that FRR does allow the thought
of using any of the 4 billion tables available to it for doing routing.
See pbr( tables in the 10k range ), `ip import-table X` and the bgp
route-map command `table X`. For where this approach is going to fall
down.

b) This patch also prevents the usage of data after it has already
been freed.  Zebra on shutdown inititates through the router_shutdown
callback a table cleanup that stores on the zfpm_g->dest_q a list
of rib_dest_t's that needs to be removed from the fpm.  This process
at the same time free's the dest->rnode, the dest->rnode->table
and the dest->rnode->info pointers.  As such they cannot be used
when the zfpm_g->dest_q wakes up to gather data for sending
down the fpm pipe.  Let's transform this problematic usage
of freed data to data we know that has not been freed yet.

Signed-off-by: Donald Sharp <sharpd@nvidia.com>
Signed-off-by: Vivek Reddy <vkarri@nvidia.com>
---
 zebra/zebra_fpm_netlink.c | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/zebra/zebra_fpm_netlink.c b/zebra/zebra_fpm_netlink.c
index 34be9fb39..233554146 100644
--- a/zebra/zebra_fpm_netlink.c
+++ b/zebra/zebra_fpm_netlink.c
@@ -279,20 +279,15 @@ static int netlink_route_info_fill(struct netlink_route_info *ri, int cmd,
 				   rib_dest_t *dest, struct route_entry *re)
 {
 	struct nexthop *nexthop;
-	struct rib_table_info *table_info =
-		rib_table_info(rib_dest_table(dest));
-	struct zebra_vrf *zvrf = table_info->zvrf;
 
 	memset(ri, 0, sizeof(*ri));
 
 	ri->prefix = rib_dest_prefix(dest);
 	ri->af = rib_dest_af(dest);
 
-	if (zvrf && zvrf->zns)
-		ri->nlmsg_pid = zvrf->zns->netlink_dplane_out.snl.nl_pid;
+	ri->nlmsg_pid = pid;
 
 	ri->nlmsg_type = cmd;
-	ri->rtm_table = zvrf_id(rib_dest_vrf(dest));
 	ri->rtm_protocol = RTPROT_UNSPEC;
 
 	/*
@@ -307,6 +302,12 @@ static int netlink_route_info_fill(struct netlink_route_info *ri, int cmd,
 		return 0;
 	}
 
+	if (re->table == RT_TABLE_DEFAULT) {
+		zfpm_debug("%s: Discard RT_TABLE_DEFAULT route", __func__);
+		return 0;
+	}
+
+	ri->rtm_table = zvrf_id(rib_dest_vrf(dest));
 	ri->rtm_protocol = netlink_proto_from_route_type(re->type);
 	ri->rtm_type = RTN_UNICAST;
 	ri->metric = &re->metric;
-- 
2.17.1

