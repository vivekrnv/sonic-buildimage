#
# Copyright (c) 2021 NVIDIA CORPORATION & AFFILIATES.
# Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This script will run after being booted into a installer kernel 
# This will setup the disk, grub etc for the actual SONiC to boot from

# NOTE: Replace these flag at build time
IMAGE_VERSION="{{IMAGE_VERSION}}"
INSTALLER_PAYLOAD="{{ONIE_INSTALLER_PAYLOAD}}"
FILESYSTEM_DOCKERFS="{{FILESYSTEM_DOCKERFS}}"
DOCKERFS_DIR="{{DOCKERFS_DIR}}"
FILESYSTEM_SQUASHFS="{{FILESYSTEM_SQUASHFS}}"
KERNEL_VERSION="{{KERNEL_VERSION}}"
BF2_GRUB_CFG="{{BF2_GRUB_CFG}}"
BF3_GRUB_CFG="{{BF3_GRUB_CFG}}"

image_dir="image-$IMAGE_VERSION"
demo_volume_revision_label="SONiC-OS-${IMAGE_VERSION}"

PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/mellanox/scripts"
CHROOT_PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

rshimlog=`which bfrshlog 2> /dev/null`
distro="SONiC"

capsule=/lib/firmware/mellanox/boot/capsule/boot_update2.cap

log()
{
	echo "INFO: $*"
	if [ -n "$rshimlog" ]; then
		$rshimlog "INFO: $*"
	fi
	if [ -e /dev/ttyAMA0 ]; then
		echo "INFO: $*" > /dev/ttyAMA0
	fi
}

function_exists()
{
	declare -f -F "$1" > /dev/null
	return $?
}

#
# Check auto configuration passed from boot-fifo
#

boot_fifo_path="/sys/bus/platform/devices/MLNXBF04:00/bootfifo"
if [ -e "${boot_fifo_path}" ]; then
	cfg_file=$(mktemp)
	# Get 16KB assuming it's big enough to hold the config file.
	dd if=${boot_fifo_path} of=${cfg_file} bs=4096 count=4

	#
	# Check the .xz signature {0xFD, '7', 'z', 'X', 'Z', 0x00} and extract the
	# config file from it. Then start decompression in the background.
	#
	offset=$(strings -a -t d ${cfg_file} | grep -m 1 "7zXZ" | awk '{print $1}')
	if [ -s "${cfg_file}" -a ."${offset}" != ."1" ]; then
		log "Found bf.cfg"
		cat ${cfg_file} | tr -d '\0' > /etc/bf.cfg
	fi
	rm -f $cfg_file
fi

if [ -e /etc/bf.cfg ]; then
	. /etc/bf.cfg
fi

ex() {
    if [[ ${DEBUG} == "all" ]]; then
        log "Executing command: $@"
    fi

    local rc=0
    $@
    rc=$?

    if [[ ${DEBUG} == "all" ]] || [[ ${DEBUG} == "error" ]]; then
        if [[ $rc -ne 0 ]]; then
            log "RC: $rc"
        fi
    fi
}

log "$distro installation started"
device=${device:-/dev/mmcblk0}
# We cannot use wait-for-root as it expects the device to contain a
# known filesystem, which might not be the case here.
while [ ! -b $device ]; do
    log "Waiting for $device to be ready"
    sleep 1
done

# Flash image
bs=512
reserved=34
boot_size_megs=50
mega=$((2**20))
boot_size_bytes=$(($boot_size_megs * $mega))

disk_sectors=`fdisk -l $device | grep "Disk $device:" | awk '{print $7}'`
disk_end=$((disk_sectors - reserved))
boot_start=2048
boot_size=$(($boot_size_bytes/$bs))
root_start=$((2048 + $boot_size))
root_end=$disk_end
root_size=$(($root_end - $root_start + 1))

dd if=/dev/zero of="$device" bs="$bs" count=1
sfdisk -f "$device" << EOF
label: gpt
label-id: A2DF9E70-6329-4679-9C1F-1DAF38AE25AE
device: ${device}
unit: sectors
first-lba: $reserved
last-lba: $disk_end

${device}p1 : start=$boot_start, size=$boot_size, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B, uuid=CEAEF8AC-B559-4D83-ACB1-A4F45B26E7F0, name="EFI System", bootable
${device}p2 : start=$root_start ,size=$root_size, type=0FC63DAF-8483-4772-8E79-3D69D8477DE4, uuid=F093FF4B-CC26-408F-81F5-FF2DD6AE139F, name="SONiC-OS"
EOF
sync

# Refresh partition table
ex blockdev --rereadpt ${device}
if function_exists bfb_pre_install; then
	log "Running bfb_pre_install from bf.cfg"
	bfb_pre_install
fi
# Generate some entropy
ex mke2fs -F ${device}p2
ex mkdosfs ${device}p1 -n "system-boot"
ex mkfs.ext4 -F ${device}p2 -L "SONiC-OS"
ex fsck.vfat -a ${device}p1
mkdir -p /mnt
ex mount -t ext4 ${device}p2 /mnt
mkdir -p /mnt/boot/efi
ex mount -t vfat ${device}p1 /mnt/boot/efi
log "Extracting SONiC files"

mkdir -p /mnt/$image_dir

# Extract the INSTALLER_PAYLOAD to the $image_dir
export EXTRACT_UNSAFE_SYMLINKS=1
ex unzip -o /debian/$INSTALLER_PAYLOAD -x $FILESYSTEM_DOCKERFS "platform.tar.gz" -d /mnt/$image_dir
mkdir -p /mnt/$image_dir/$DOCKERFS_DIR
unzip -op /debian/$INSTALLER_PAYLOAD "$FILESYSTEM_DOCKERFS" | tar xz --warning=no-timestamp -f - -C /mnt/$image_dir/$DOCKERFS_DIR

mkdir -p /mnt/$image_dir/platform
unzip -op /debian/$INSTALLER_PAYLOAD "platform.tar.gz" | tar xz --warning=no-timestamp -f - -C /mnt/$image_dir/platform

# Query the base mac via mlxfwmanager
base_mac=$(mlxfwmanager | grep 'Base MAC' | awk '{split($0,a," "); print a[3]}' | fold -w2 | paste -sd ":" -)

# Copy in the machine.conf file
cat <<EOF > /mnt/machine.conf
bf_vendor=nvidia
bf_machine=nvidia-bluefield
bf_arch=arm64
bf_base_mac=$base_mac
EOF

chmod a+r /mnt/machine.conf

sync

log "Installing GRUB"

ex grub-install \
    --bootloader-id="SONiC-OS" \
    --efi-directory=/mnt/boot/efi/ \
    --boot-directory=/mnt/ \
    ${device}p1

# Create a minimal grub.cfg that allows for:
#   - configure the serial console
#   - allows for grub-reboot to work
#   - a menu entry for the DEMO OS

grub_cfg=$(mktemp)

# Modify GRUB_CMDLINE_LINUX from bf.cfg file if required

if (lspci -n -d 15b3: | grep -wq 'a2dc'); then
    DEFAULT_GRUB_CMDLINE_LINUX=$BF3_GRUB_CFG
else
    DEFAULT_GRUB_CMDLINE_LINUX=$BF2_GRUB_CFG
fi

GRUB_CMDLINE_LINUX=${GRUB_CMDLINE_LINUX:-"$DEFAULT_GRUB_CMDLINE_LINUX"}
export GRUB_CMDLINE_LINUX

# Add a menu entry for the SONiC OS
# Note: assume that apparmor is supported in the kernel
demo_grub_entry="$demo_volume_revision_label"

# Find the grub_cfg_root
uuid=$(blkid ${device}p2 | sed -ne 's/.* UUID=\"\([^"]*\)\".*/\1/p')
if [ -z "$uuid" ]; then
	grub_cfg_root=${device}p2
else
	grub_cfg_root=UUID=$uuid
fi


cat <<EOF >> $grub_cfg
{{GRUB_CFG}}
EOF

# Copy the grub.cfg onto the boot-directory as specified in the grub-install
ex mkdir -p /mnt/grub 
ex cp $grub_cfg /mnt/grub/grub.cfg

sync

log "GRUB CFG Updated"

# Update HW-dependant files
if (/usr/bin/lspci -n -d 15b3: | grep -wq 'a2d2'); then
    # BlueField-1
    if [ ! -n "$DHCP_CLASS_ID" ]; then
        DHCP_CLASS_ID="BF1Client"
    fi
elif (/usr/bin/lspci -n -d 15b3: | grep -wq 'a2d6'); then
    # BlueField-2
    if [ ! -n "$DHCP_CLASS_ID" ]; then
        DHCP_CLASS_ID="BF2Client"
    fi
fi

ex echo $DHCP_CLASS_ID

umount /mnt/boot/efi
umount /mnt

ex blockdev --rereadpt ${device}

ex fsck.vfat -a ${device}p1
sync

if [ -e ${capsule} ]; then
    log "Update capsule: ${capsule}"
    ex bfrec --capsule ${capsule}
fi

ex bfbootmgr --cleanall

# Make it the boot partition
mounted_efivarfs=0
if [ ! -d /sys/firmware/efi/efivars ]; then
	ex mount -t efivarfs none /sys/firmware/efi/efivars
	mounted_efivarfs=1
fi

log "Updating EFIBootMgr"

if efibootmgr | grep SONiC-OS; then
    ex efibootmgr -b "$(efibootmgr | grep SONiC-OS | cut -c 5-8)" -B
fi
ex efibootmgr -c -d "$device" -p 1 -L SONiC-OS -l "\EFI\SONiC-OS\grubaa64.efi"

BFCFG=`which bfcfg 2> /dev/null`
if [ -n "$BFCFG" ]; then
	# Create PXE boot entries
	# Not adding CX ifaces because presumably they'll not be used for PXE
	if [ -e /etc/bf.cfg ]; then
		mv /etc/bf.cfg /etc/bf.cfg.orig
	fi

	cat > /etc/bf.cfg << EOF
BOOT0=DISK
BOOT1=NET-OOB-IPV4
BOOT2=NET-OOB-IPV6
BOOT3=NET-RSHIM-IPV4
BOOT4=NET-RSHIM-IPV6
PXE_DHCP_CLASS_ID=$DHCP_CLASS_ID
EOF

	ex $BFCFG

	# Restore the original bf.cfg
	/bin/rm -f /etc/bf.cfg
	if [ -e /etc/bf.cfg.orig ]; then
		mv /etc/bf.cfg.orig /etc/bf.cfg
	fi
fi

if [ $mounted_efivarfs -eq 1 ]; then
	umount /sys/firmware/efi/efivars > /dev/null 2>&1
fi

if [ -n "$BFCFG" ]; then
	ex $BFCFG
fi

if function_exists bfb_post_install; then
	ex bfb_post_install
fi

log "Installation finished"
log "Rebooting..."
# Wait for these messages to be pulled by the rshim service
sleep 3
